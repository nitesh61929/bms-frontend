{"version":3,"file":"service-worker.d.ts","sources":["service-worker.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v11.1.2\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { InjectionToken } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { ModuleWithProviders } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare class ServiceWorkerModule {\r\n    /**\r\n     * Register the given Angular Service Worker script.\r\n     *\r\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\r\n     * workers are not supported by the browser, and the service worker will not be registered.\r\n     */\r\n    static register(script: string, opts?: SwRegistrationOptions): ModuleWithProviders<ServiceWorkerModule>;\r\n}\r\n\r\n/**\r\n * Subscribe and listen to\r\n * [Web Push\r\n * Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices) through\r\n * Angular Service Worker.\r\n *\r\n * @usageNotes\r\n *\r\n * You can inject a `SwPush` instance into any component or service\r\n * as a dependency.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"inject-sw-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.\r\n * The call returns a `Promise` with a new\r\n * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\r\n * instance.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * A request is rejected if the user denies permission, or if the browser\r\n * blocks or does not support the Push API or ServiceWorkers.\r\n * Check `SwPush.isEnabled` to confirm status.\r\n *\r\n * Invoke Push Notifications by pushing a message with the following payload.\r\n *\r\n * ```ts\r\n * {\r\n *   \"notification\": {\r\n *     \"actions\": NotificationAction[],\r\n *     \"badge\": USVString\r\n *     \"body\": DOMString,\r\n *     \"data\": any,\r\n *     \"dir\": \"auto\"|\"ltr\"|\"rtl\",\r\n *     \"icon\": USVString,\r\n *     \"image\": USVString,\r\n *     \"lang\": DOMString,\r\n *     \"renotify\": boolean,\r\n *     \"requireInteraction\": boolean,\r\n *     \"silent\": boolean,\r\n *     \"tag\": DOMString,\r\n *     \"timestamp\": DOMTimeStamp,\r\n *     \"title\": DOMString,\r\n *     \"vibrate\": number[]\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Only `title` is required. See `Notification`\r\n * [instance\r\n * properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).\r\n *\r\n * While the subscription is active, Service Worker listens for\r\n * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\r\n * occurrences and creates\r\n * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)\r\n * instances in response.\r\n *\r\n * Unsubscribe using `SwPush.unsubscribe()`.\r\n *\r\n * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user\r\n * clicks on a notification. For example:\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-notification-clicks\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)\r\n * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)\r\n * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)\r\n * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)\r\n * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class SwPush {\r\n    private sw;\r\n    /**\r\n     * Emits the payloads of the received push notification messages.\r\n     */\r\n    readonly messages: Observable<object>;\r\n    /**\r\n     * Emits the payloads of the received push notification messages as well as the action the user\r\n     * interacted with. If no action was used the `action` property contains an empty string `''`.\r\n     *\r\n     * Note that the `notification` property does **not** contain a\r\n     * [Notification][Mozilla Notification] object but rather a\r\n     * [NotificationOptions](https://notifications.spec.whatwg.org/#dictdef-notificationoptions)\r\n     * object that also includes the `title` of the [Notification][Mozilla Notification] object.\r\n     *\r\n     * [Mozilla Notification]: https://developer.mozilla.org/en-US/docs/Web/API/Notification\r\n     */\r\n    readonly notificationClicks: Observable<{\r\n        action: string;\r\n        notification: NotificationOptions & {\r\n            title: string;\r\n        };\r\n    }>;\r\n    /**\r\n     * Emits the currently active\r\n     * [PushSubscription](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\r\n     * associated to the Service Worker registration or `null` if there is no subscription.\r\n     */\r\n    readonly subscription: Observable<PushSubscription | null>;\r\n    /**\r\n     * True if the Service Worker is enabled (supported by the browser and enabled via\r\n     * `ServiceWorkerModule`).\r\n     */\r\n    get isEnabled(): boolean;\r\n    private pushManager;\r\n    private subscriptionChanges;\r\n    constructor(sw: ɵangular_packages_service_worker_service_worker_a);\r\n    /**\r\n     * Subscribes to Web Push Notifications,\r\n     * after requesting and receiving user permission.\r\n     *\r\n     * @param options An object containing the `serverPublicKey` string.\r\n     * @returns A Promise that resolves to the new subscription object.\r\n     */\r\n    requestSubscription(options: {\r\n        serverPublicKey: string;\r\n    }): Promise<PushSubscription>;\r\n    /**\r\n     * Unsubscribes from Service Worker push notifications.\r\n     *\r\n     * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no\r\n     *          active subscription or the unsubscribe operation fails.\r\n     */\r\n    unsubscribe(): Promise<void>;\r\n    private decodeBase64;\r\n}\r\n\r\n/**\r\n * Token that can be used to provide options for `ServiceWorkerModule` outside of\r\n * `ServiceWorkerModule.register()`.\r\n *\r\n * You can use this token to define a provider that generates the registration options at runtime,\r\n * for example via a function call:\r\n *\r\n * {@example service-worker/registration-options/module.ts region=\"registration-options\"\r\n *     header=\"app.module.ts\"}\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class SwRegistrationOptions {\r\n    /**\r\n     * Whether the ServiceWorker will be registered and the related services (such as `SwPush` and\r\n     * `SwUpdate`) will attempt to communicate and interact with it.\r\n     *\r\n     * Default: true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * A URL that defines the ServiceWorker's registration scope; that is, what range of URLs it can\r\n     * control. It will be used when calling\r\n     * [ServiceWorkerContainer#register()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\r\n     */\r\n    scope?: string;\r\n    /**\r\n     * Defines the ServiceWorker registration strategy, which determines when it will be registered\r\n     * with the browser.\r\n     *\r\n     * The default behavior of registering once the application stabilizes (i.e. as soon as there are\r\n     * no pending micro- and macro-tasks) is designed to register the ServiceWorker as soon as\r\n     * possible but without affecting the application's first time load.\r\n     *\r\n     * Still, there might be cases where you want more control over when the ServiceWorker is\r\n     * registered (for example, there might be a long-running timeout or polling interval, preventing\r\n     * the app from stabilizing). The available option are:\r\n     *\r\n     * - `registerWhenStable:<timeout>`: Register as soon as the application stabilizes (no pending\r\n     *     micro-/macro-tasks) but no later than `<timeout>` milliseconds. If the app hasn't\r\n     *     stabilized after `<timeout>` milliseconds (for example, due to a recurrent asynchronous\r\n     *     task), the ServiceWorker will be registered anyway.\r\n     *     If `<timeout>` is omitted, the ServiceWorker will only be registered once the app\r\n     *     stabilizes.\r\n     * - `registerImmediately`: Register immediately.\r\n     * - `registerWithDelay:<timeout>`: Register with a delay of `<timeout>` milliseconds. For\r\n     *     example, use `registerWithDelay:5000` to register the ServiceWorker after 5 seconds. If\r\n     *     `<timeout>` is omitted, is defaults to `0`, which will register the ServiceWorker as soon\r\n     *     as possible but still asynchronously, once all pending micro-tasks are completed.\r\n     * - An [Observable](guide/observables) factory function: A function that returns an `Observable`.\r\n     *     The function will be used at runtime to obtain and subscribe to the `Observable` and the\r\n     *     ServiceWorker will be registered as soon as the first value is emitted.\r\n     *\r\n     * Default: 'registerWhenStable:30000'\r\n     */\r\n    registrationStrategy?: string | (() => Observable<unknown>);\r\n}\r\n\r\n/**\r\n * Subscribe to update notifications from the Service Worker, trigger update\r\n * checks, and forcibly activate updates.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\r\nexport declare class SwUpdate {\r\n    private sw;\r\n    /**\r\n     * Emits an `UpdateAvailableEvent` event whenever a new app version is available.\r\n     */\r\n    readonly available: Observable<UpdateAvailableEvent>;\r\n    /**\r\n     * Emits an `UpdateActivatedEvent` event whenever the app has been updated to a new version.\r\n     */\r\n    readonly activated: Observable<UpdateActivatedEvent>;\r\n    /**\r\n     * Emits an `UnrecoverableStateEvent` event whenever the version of the app used by the service\r\n     * worker to serve this client is in a broken state that cannot be recovered from without a full\r\n     * page reload.\r\n     */\r\n    readonly unrecoverable: Observable<UnrecoverableStateEvent>;\r\n    /**\r\n     * True if the Service Worker is enabled (supported by the browser and enabled via\r\n     * `ServiceWorkerModule`).\r\n     */\r\n    get isEnabled(): boolean;\r\n    constructor(sw: ɵangular_packages_service_worker_service_worker_a);\r\n    checkForUpdate(): Promise<void>;\r\n    activateUpdate(): Promise<void>;\r\n}\r\n\r\ndeclare interface TypedEvent {\r\n    type: string;\r\n}\r\n\r\n/**\r\n * An event emitted when the version of the app used by the service worker to serve this client is\r\n * in a broken state that cannot be recovered from and a full page reload is required.\r\n *\r\n * For example, the service worker may not be able to retrieve a required resource, neither from the\r\n * cache nor from the server. This could happen if a new version is deployed to the server and the\r\n * service worker cache has been partially cleaned by the browser, removing some files of a previous\r\n * app version but not all.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface UnrecoverableStateEvent {\r\n    type: 'UNRECOVERABLE_STATE';\r\n    reason: string;\r\n}\r\n\r\n/**\r\n * An event emitted when a new version of the app has been downloaded and activated.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface UpdateActivatedEvent {\r\n    type: 'UPDATE_ACTIVATED';\r\n    previous?: {\r\n        hash: string;\r\n        appData?: Object;\r\n    };\r\n    current: {\r\n        hash: string;\r\n        appData?: Object;\r\n    };\r\n}\r\n\r\n/**\r\n * An event emitted when a new version of the app is available.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface UpdateAvailableEvent {\r\n    type: 'UPDATE_AVAILABLE';\r\n    current: {\r\n        hash: string;\r\n        appData?: Object;\r\n    };\r\n    available: {\r\n        hash: string;\r\n        appData?: Object;\r\n    };\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare class ɵangular_packages_service_worker_service_worker_a {\r\n    private serviceWorker;\r\n    readonly worker: Observable<ServiceWorker>;\r\n    readonly registration: Observable<ServiceWorkerRegistration>;\r\n    readonly events: Observable<TypedEvent>;\r\n    constructor(serviceWorker: ServiceWorkerContainer | undefined);\r\n    postMessage(action: string, payload: Object): Promise<void>;\r\n    postMessageWithStatus(type: string, payload: Object, nonce: number): Promise<void>;\r\n    generateNonce(): number;\r\n    eventsOfType<T extends TypedEvent>(type: T['type']): Observable<T>;\r\n    nextEventOfType<T extends TypedEvent>(type: T['type']): Observable<T>;\r\n    waitForStatus(nonce: number): Promise<void>;\r\n    get isEnabled(): boolean;\r\n}\r\n\r\nexport declare const ɵangular_packages_service_worker_service_worker_b: InjectionToken<string>;\r\n\r\nexport declare function ɵangular_packages_service_worker_service_worker_c(injector: Injector, script: string, options: SwRegistrationOptions, platformId: string): Function;\r\n\r\nexport declare function ɵangular_packages_service_worker_service_worker_d(opts: SwRegistrationOptions, platformId: string): ɵangular_packages_service_worker_service_worker_a;\r\n\r\nexport { }\r\n"]}