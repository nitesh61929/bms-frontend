"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRules = void 0;
const conversionError_1 = require("../../../errors/conversionError");
const convertRule_1 = require("./convertRule");
const convertTSLintRuleSeverity_1 = require("./formats/convertTSLintRuleSeverity");
const formatRawTslintRule_1 = require("./formats/formatRawTslintRule");
/**
 * Converts raw TSLint rules to their ESLint equivalents.
 * @see `/docs/Architecture/Linting.md` for documentation.
 */
const convertRules = (dependencies, rawTslintRules, ruleEquivalents) => {
    var _a, _b;
    const converted = new Map();
    const failed = [];
    const missing = [];
    const plugins = new Set();
    if (rawTslintRules !== undefined) {
        for (const [ruleName, value] of Object.entries(rawTslintRules)) {
            // 1. The raw TSLint rule is converted to a standardized format.
            const tslintRule = formatRawTslintRule_1.formatRawTslintRule(ruleName, value);
            // 2. The appropriate converter is run for the rule.
            const conversion = convertRule_1.convertRule(tslintRule, dependencies.ruleConverters);
            // 3. If the rule is missing or the conversion failed, this is marked.
            if (conversion === undefined) {
                if (tslintRule.ruleSeverity !== "off") {
                    missing.push(tslintRule);
                }
                continue;
            }
            if (conversion instanceof conversionError_1.ConversionError) {
                failed.push(conversion);
                continue;
            }
            const equivalents = new Set();
            // 4. For each output rule equivalent given by the conversion:
            for (const changes of conversion.rules) {
                // 4a. The output rule name is added to the TSLint rule's equivalency set.
                equivalents.add(changes.ruleName);
                // 4b. The TSLint rule's config severity is mapped to its ESLint equivalent.
                const existingConversion = converted.get(changes.ruleName);
                const newConversion = {
                    ...changes,
                    ruleSeverity: convertTSLintRuleSeverity_1.convertTSLintRuleSeverity(tslintRule.ruleSeverity),
                };
                // 4c. If this is the first time the output ESLint rule is seen, it's directly marked as converted.
                if (existingConversion === undefined) {
                    converted.set(changes.ruleName, newConversion);
                    continue;
                }
                // 4d. If not, a rule merger is run to combine it with its existing output settings.
                const merger = dependencies.ruleMergers.get(changes.ruleName);
                if (merger === undefined) {
                    failed.push(conversionError_1.ConversionError.forMerger(changes.ruleName));
                }
                else {
                    const existingNotices = (_a = existingConversion.notices) !== null && _a !== void 0 ? _a : [];
                    const newNotices = (_b = newConversion.notices) !== null && _b !== void 0 ? _b : [];
                    converted.set(changes.ruleName, {
                        ...existingConversion,
                        ruleArguments: merger(existingConversion.ruleArguments, newConversion.ruleArguments),
                        notices: Array.from(new Set([...existingNotices, ...newNotices])),
                    });
                }
            }
            if (conversion.plugins !== undefined) {
                for (const newPlugin of conversion.plugins) {
                    plugins.add(newPlugin);
                }
            }
            ruleEquivalents.set(tslintRule.ruleName, Array.from(equivalents));
        }
    }
    return { converted, failed, missing, plugins, ruleEquivalents };
};
exports.convertRules = convertRules;
//# sourceMappingURL=convertRules.js.map