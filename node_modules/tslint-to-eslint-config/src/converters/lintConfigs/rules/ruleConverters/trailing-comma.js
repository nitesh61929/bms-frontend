"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertTrailingComma = void 0;
const unsupportedKeyInEsLint = "typeLiterals";
const convertTrailingComma = (tslintRule) => {
    const eslintArgs = tslintRule.ruleArguments.length
        ? collectArguments(tslintRule.ruleArguments)
        : undefined;
    const notices = tslintRule.ruleArguments.length
        ? collectNotices(tslintRule.ruleArguments)
        : undefined;
    return {
        rules: [
            {
                ruleName: "comma-dangle",
                ...(eslintArgs && { ruleArguments: [eslintArgs] }),
                ...((notices === null || notices === void 0 ? void 0 : notices.length) && { notices }),
            },
        ],
    };
};
exports.convertTrailingComma = convertTrailingComma;
function collectArguments(args) {
    const tslintArg = args[0];
    const { singleline, multiline } = tslintArg;
    if (typeof singleline === "object" || typeof multiline === "object") {
        const keys = mergePropertyKeys(singleline, multiline);
        const single = singleline && mapToObjectConfig(singleline);
        const multi = multiline && mapToObjectConfig(multiline);
        return keys.reduce((acc, key) => ({
            ...acc,
            ...collectKeys(key, single, multi),
        }), {});
    }
    if ((singleline === undefined || singleline === "never") && multiline === "always") {
        return "always-multiline";
    }
    if (singleline === "always" && multiline === "always") {
        return "always";
    }
    return;
}
function mergePropertyKeys(singleline, multiline) {
    const getKeysIfObject = (field) => typeof field === "object" ? Object.keys(field) : [];
    const singlelineKeys = getKeysIfObject(singleline);
    const multilineKeys = getKeysIfObject(multiline);
    const uniqueKeys = [...new Set([...singlelineKeys, ...multilineKeys])];
    return uniqueKeys.filter((field) => field !== unsupportedKeyInEsLint);
}
function collectKeys(key, singleline, multiline) {
    const hasSingleline = Boolean(singleline);
    const hasSinglelineAndFieldExist = Boolean(singleline === null || singleline === void 0 ? void 0 : singleline[key]);
    const hasSinglelineAlways = Boolean(singleline && singleline[key] === "always");
    const hasMultilineAlways = Boolean(multiline && multiline[key] === "always");
    if (!hasSingleline && hasMultilineAlways) {
        return {
            [key]: "always-multiline",
        };
    }
    if (!hasSinglelineAndFieldExist && hasMultilineAlways) {
        return {
            [key]: "always-multiline",
        };
    }
    if (!hasSinglelineAlways && hasMultilineAlways) {
        return {
            [key]: "always-multiline",
        };
    }
    if (hasSinglelineAlways && hasMultilineAlways) {
        return {
            [key]: "always",
        };
    }
    return {
        [key]: "never",
    };
}
function mapToObjectConfig(value) {
    return typeof value === "string"
        ? {
            arrays: value,
            objects: value,
            functions: value,
            imports: value,
            exports: value,
        }
        : value;
}
function collectNotices(args) {
    const tslintArg = args[0];
    return [buildNoticeForEsSpecCompliant(tslintArg), buildNoticeForTypeLiterals(tslintArg)].filter(Boolean);
}
function buildNoticeForEsSpecCompliant(arg) {
    if (arg.esSpecCompliant === false) {
        return `ESLint only supports esSpecCompliant enabled`;
    }
    return "";
}
function buildNoticeForTypeLiterals(arg) {
    const { singleline, multiline } = arg;
    const hasTypeLiterals = (field) => typeof field === "object" && Object.keys(field).includes(unsupportedKeyInEsLint);
    if (hasTypeLiterals(singleline) || hasTypeLiterals(multiline)) {
        return `ESLint does not support config property ${unsupportedKeyInEsLint}`;
    }
    return "";
}
//# sourceMappingURL=trailing-comma.js.map