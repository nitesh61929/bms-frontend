"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertImportBlacklist = void 0;
const NOTICE_MATCH_PATTERNS = "ESLint and TSLint use different strategies to match patterns. TSLint uses standard regular expressions, but ESLint .gitignore spec.";
const convertImportBlacklist = (tslintRule) => {
    let ruleArguments = [];
    const notices = [];
    if (tslintRule.ruleArguments.every(isString)) {
        ruleArguments = tslintRule.ruleArguments;
    }
    else {
        const objectOption = tslintRule.ruleArguments.reduce((rules, rule) => {
            if (!Array.isArray(rule)) {
                const eslintRule = isString(rule)
                    ? rule
                    : {
                        name: Object.keys(rule)[0],
                        importNames: Object.values(rule)[0],
                    };
                return { ...rules, paths: [...(rules.paths || []), eslintRule] };
            }
            return { ...rules, patterns: [...(rules.patterns || []), ...rule] };
        }, {});
        if ("patterns" in objectOption && objectOption.patterns.length > 0) {
            notices.push(NOTICE_MATCH_PATTERNS);
        }
        ruleArguments = [objectOption];
    }
    return {
        rules: [
            {
                ruleArguments,
                ...(notices.length > 0 && { notices }),
                ruleName: "no-restricted-imports",
            },
        ],
    };
};
exports.convertImportBlacklist = convertImportBlacklist;
function isString(value) {
    return typeof value === "string";
}
//# sourceMappingURL=import-blacklist.js.map