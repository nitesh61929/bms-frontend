"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.summarizePackageRules = void 0;
const utils_1 = require("../../../utils");
const normalizeExtensions_1 = require("../pruning/normalizeExtensions");
const collectTSLintRulesets_1 = require("./collectTSLintRulesets");
const normalizeESLintRules_1 = require("./normalizeESLintRules");
/**
 * Given an initial set of rule conversion results and original configurations,
 * determines which ESLint rulesets to extend from and removes redundant rule values.
 */
const summarizePackageRules = async (dependencies, eslint, tslint, ruleConversionResults, prettierRequested) => {
    var _a;
    const extendedESLintRulesets = (_a = eslint === null || eslint === void 0 ? void 0 : eslint.full.extends) !== null && _a !== void 0 ? _a : [];
    const extendedTSLintRulesets = collectTSLintRulesets_1.collectTSLintRulesets(tslint);
    const allExtensions = utils_1.uniqueFromSources(extendedESLintRulesets, extendedTSLintRulesets);
    // 3a. If no output rules conflict with `eslint-config-prettier`, it's added in
    if (dependencies.checkPrettierExtension(ruleConversionResults, prettierRequested)) {
        allExtensions.push("prettier", "prettier/@typescript-eslint");
    }
    if (allExtensions.length === 0) {
        return {
            ...ruleConversionResults,
            extends: [],
            extensionRules: new Map(),
        };
    }
    // 3b. Any ESLint rules that are configured the same as an extended preset are trimmed
    const { configurationErrors, importedExtensions } = await dependencies.retrieveExtendsValues(utils_1.uniqueFromSources(extendedESLintRulesets, extendedTSLintRulesets));
    const extensionRules = normalizeExtensions_1.normalizeExtensions(importedExtensions);
    const deduplicated = dependencies.removeExtendsDuplicatedRules(new Map([
        ...Array.from(normalizeESLintRules_1.normalizeESLintRules(eslint === null || eslint === void 0 ? void 0 : eslint.full.rules)),
        ...Array.from(ruleConversionResults.converted),
    ]), extensionRules);
    return {
        ...ruleConversionResults,
        converted: deduplicated.differentRules,
        extends: utils_1.uniqueFromSources(allExtensions),
        extensionRules: deduplicated.extensionRules,
        failed: [...ruleConversionResults.failed, ...configurationErrors],
    };
};
exports.summarizePackageRules = summarizePackageRules;
//# sourceMappingURL=summarizePackageRules.js.map