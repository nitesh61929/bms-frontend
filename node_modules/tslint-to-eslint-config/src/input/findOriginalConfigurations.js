"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findOriginalConfigurations = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
/**
 * Searches for all relevant input configurations on disk.
 */
const findOriginalConfigurations = async (dependencies, locations) => {
    var _a;
    // Simultaneously search for all required configuration types
    const [eslint, packages, tslint, typescript] = await Promise.all([
        dependencies.findESLintConfiguration(locations),
        dependencies.findPackagesConfiguration(locations.package),
        dependencies.findTSLintConfiguration(locations.tslint),
        dependencies.findTypeScriptConfiguration(locations.typescript),
    ]);
    // Out of those configurations, only TSLint's is always required to run
    if (tslint instanceof Error) {
        return {
            complaints: [(_a = getMissingPackageMessage(tslint)) !== null && _a !== void 0 ? _a : tslint.message],
            status: types_1.ResultStatus.ConfigurationError,
        };
    }
    const configurationResults = [
        [eslint, "eslint"],
        [packages, "package"],
        [typescript, "typescript"],
    ];
    // Other configuration errors only halt the program if...
    const errorMessages = configurationResults
        .map(([error, key]) => {
        if (!(error instanceof Error)) {
            return undefined;
        }
        // * Their failure was caused by a missing package that needs to be installed
        const missingPackageMessage = getMissingPackageMessage(error);
        if (missingPackageMessage !== undefined) {
            return missingPackageMessage;
        }
        // * The user explicitly asked for them
        if (typeof locations[key] === "string") {
            return error.message;
        }
        return undefined;
    })
        .filter(utils_1.isDefined);
    if (errorMessages.length !== 0) {
        return {
            complaints: errorMessages,
            status: types_1.ResultStatus.ConfigurationError,
        };
    }
    return {
        data: {
            ...(!(eslint instanceof Error) && { eslint }),
            ...(!(packages instanceof Error) && { packages }),
            tslint: dependencies.mergeLintConfigurations(eslint, tslint),
            ...(!(typescript instanceof Error) && { typescript }),
        },
        status: types_1.ResultStatus.Succeeded,
    };
};
exports.findOriginalConfigurations = findOriginalConfigurations;
const getMissingPackageMessage = (error) => {
    const match = /(Cannot find module|could not require|couldn't find the plugin) ([a-zA-Z0-9-_"'@/]+)/.exec(error.message);
    if (match === null) {
        return undefined;
    }
    return `Could not import the ${match[2]} module. Do you need to install packages?`;
};
//# sourceMappingURL=findOriginalConfigurations.js.map