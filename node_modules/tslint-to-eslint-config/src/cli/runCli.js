"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCli = void 0;
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const os_1 = require("os");
const package_json_1 = require("../../package.json");
const reporting_1 = require("../reporting");
const types_1 = require("../types");
/**
 * @see `/docs/Architecture/README.md` for documentation.
 */
const runCli = async (dependencies, rawArgv) => {
    // 1. CLI options are parsed from the raw arguments into a commands object.
    const command = new commander_1.Command()
        .storeOptionsAsProperties(false)
        .usage("[options] <file ...> --language [language]")
        .option("--comments [files]", "convert tslint:disable rule flags in files (experimental)")
        .option("--config [config]", "eslint configuration file to output to")
        .option("--editor [editor]", "editor configuration file to convert")
        .option("--eslint [eslint]", "eslint configuration file to convert using")
        .option("--package [package]", "package configuration file to convert using")
        .option("--prettier [prettier]", "add eslint-config-prettier to the plugins list")
        .option("--tslint [tslint]", "tslint configuration file to convert using")
        .option("--typescript [typescript]", "typescript configuration file to convert using")
        .option("-V, --version", "output the package version");
    const parsedArgv = {
        config: "./.eslintrc.js",
        ...command.parse(rawArgv).opts(),
    };
    // 2. If the version should be printed, we do that and stop execution.
    if (command.opts().version) {
        dependencies.logger.stdout.write(`${package_json_1.version}${os_1.EOL}`);
        return types_1.ResultStatus.Succeeded;
    }
    // 3. Any existing linter and TypeScript configurations are read from disk.
    const originalConfigurations = await dependencies.findOriginalConfigurations(parsedArgv);
    if (originalConfigurations.status !== types_1.ResultStatus.Succeeded) {
        reporting_1.logErrorResult(originalConfigurations, dependencies.logger);
        return originalConfigurations.status;
    }
    // 4. Each converter is run, halting execution if it fails.
    for (const converter of dependencies.converters) {
        const result = await tryConvertConfig(converter, parsedArgv, originalConfigurations.data);
        if (result.status !== types_1.ResultStatus.Succeeded) {
            reporting_1.logErrorResult(result, dependencies.logger);
            return result.status;
        }
    }
    dependencies.logger.stdout.write(chalk_1.default.greenBright(`${os_1.EOL}✅ All is well! ✅\n`));
    return types_1.ResultStatus.Succeeded;
};
exports.runCli = runCli;
const tryConvertConfig = async (converter, argv, originalConfigurations) => {
    const ruleEquivalents = new Map();
    let result;
    try {
        result = await converter(argv, originalConfigurations, ruleEquivalents);
    }
    catch (error) {
        result = {
            errors: [error],
            status: types_1.ResultStatus.Failed,
        };
    }
    return result;
};
//# sourceMappingURL=runCli.js.map