"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortObjectByKeys = exports.createRootESLintConfigFile = exports.removeTSLintJSONForProject = exports.createESLintConfigForProject = exports.createRootESLintConfig = exports.setESLintProjectBasedOnProjectType = exports.getAllSourceFilesForProject = exports.addESLintTargetToProject = exports.updateWorkspaceInTree = exports.offsetFromRoot = exports.getProjectConfig = exports.updateJsonInTree = exports.readJsonInTree = void 0;
/**
 * Some utils taken from various parts of Nx:
 * https://github.com/nrwl/nx
 *
 * Thanks, Nrwl folks!
 */
const core_1 = require("@angular-devkit/core");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
/**
 * This method is specifically for reading JSON files in a Tree
 * @param host The host tree
 * @param path The path to the JSON file
 * @returns The JSON data in the file.
 */
function readJsonInTree(host, path) {
    if (!host.exists(path)) {
        throw new Error(`Cannot find ${path}`);
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const contents = strip_json_comments_1.default(host.read(path).toString('utf-8'));
    try {
        return JSON.parse(contents);
    }
    catch (e) {
        throw new Error(`Cannot parse ${path}: ${e.message}`);
    }
}
exports.readJsonInTree = readJsonInTree;
/**
 * This method is specifically for updating JSON in a Tree
 * @param path Path of JSON file in the Tree
 * @param callback Manipulation of the JSON data
 * @returns A rule which updates a JSON file file in a Tree
 */
function updateJsonInTree(path, callback) {
    return (host, context) => {
        if (!host.exists(path)) {
            host.create(path, serializeJson(callback({}, context)));
            return host;
        }
        host.overwrite(path, serializeJson(callback(readJsonInTree(host, path), context)));
        return host;
    };
}
exports.updateJsonInTree = updateJsonInTree;
function getWorkspacePath(host) {
    const possibleFiles = ['/workspace.json', '/angular.json', '/.angular.json'];
    return possibleFiles.filter((path) => host.exists(path))[0];
}
function getProjectConfig(host, name) {
    const workspaceJson = readJsonInTree(host, getWorkspacePath(host));
    const projectConfig = workspaceJson.projects[name];
    if (!projectConfig) {
        throw new Error(`Cannot find project '${name}'`);
    }
    else {
        return projectConfig;
    }
}
exports.getProjectConfig = getProjectConfig;
function offsetFromRoot(fullPathToSourceDir) {
    const parts = core_1.normalize(fullPathToSourceDir).split('/');
    let offset = '';
    for (let i = 0; i < parts.length; ++i) {
        offset += '../';
    }
    return offset;
}
exports.offsetFromRoot = offsetFromRoot;
function serializeJson(json) {
    return `${JSON.stringify(json, null, 2)}\n`;
}
function updateWorkspaceInTree(callback) {
    return (host, context) => {
        const path = getWorkspacePath(host);
        host.overwrite(path, serializeJson(callback(readJsonInTree(host, path), context, host)));
        return host;
    };
}
exports.updateWorkspaceInTree = updateWorkspaceInTree;
function addESLintTargetToProject(projectName, targetName) {
    return updateWorkspaceInTree((workspaceJson) => {
        const existingProjectConfig = workspaceJson.projects[projectName];
        let lintFilePatternsRoot = '';
        // Default Angular CLI project at the root of the workspace
        if (existingProjectConfig.root === '') {
            lintFilePatternsRoot = 'src';
        }
        else {
            lintFilePatternsRoot = existingProjectConfig.root;
        }
        const eslintTargetConfig = {
            builder: '@angular-eslint/builder:lint',
            options: {
                lintFilePatterns: [
                    `${lintFilePatternsRoot}/**/*.ts`,
                    `${lintFilePatternsRoot}/**/*.html`,
                ],
            },
        };
        existingProjectConfig.architect[targetName] = eslintTargetConfig;
        return workspaceJson;
    });
}
exports.addESLintTargetToProject = addESLintTargetToProject;
function allFilesInDirInHost(host, path, options = { recursive: true }) {
    const dir = host.getDir(path);
    const res = [];
    dir.subfiles.forEach((p) => {
        res.push(core_1.join(path, p));
    });
    if (!options.recursive) {
        return res;
    }
    dir.subdirs.forEach((p) => {
        res.push(...allFilesInDirInHost(host, core_1.join(path, p)));
    });
    return res;
}
function getAllSourceFilesForProject(host, projectName) {
    const workspaceJson = readJsonInTree(host, 'angular.json');
    const existingProjectConfig = workspaceJson.projects[projectName];
    let pathRoot = '';
    // Default Angular CLI project at the root of the workspace
    if (existingProjectConfig.root === '') {
        pathRoot = 'src';
    }
    else {
        pathRoot = existingProjectConfig.root;
    }
    return allFilesInDirInHost(host, core_1.normalize(pathRoot));
}
exports.getAllSourceFilesForProject = getAllSourceFilesForProject;
function setESLintProjectBasedOnProjectType(projectRoot, projectType) {
    let project;
    if (projectType === 'application') {
        project = [
            `${projectRoot}/tsconfig.app.json`,
            `${projectRoot}/tsconfig.spec.json`,
            `${projectRoot}/e2e/tsconfig.json`,
        ];
    }
    // Libraries don't have an e2e directory
    if (projectType === 'library') {
        project = [
            `${projectRoot}/tsconfig.lib.json`,
            `${projectRoot}/tsconfig.spec.json`,
        ];
    }
    return project;
}
exports.setESLintProjectBasedOnProjectType = setESLintProjectBasedOnProjectType;
function createRootESLintConfig(prefix) {
    let codeRules;
    if (prefix) {
        codeRules = {
            '@angular-eslint/directive-selector': [
                'error',
                { type: 'attribute', prefix, style: 'camelCase' },
            ],
            '@angular-eslint/component-selector': [
                'error',
                { type: 'element', prefix, style: 'kebab-case' },
            ],
        };
    }
    else {
        codeRules = {};
    }
    return {
        root: true,
        ignorePatterns: ['projects/**/*'],
        overrides: [
            {
                files: ['*.ts'],
                parserOptions: {
                    project: ['tsconfig.json', 'e2e/tsconfig.json'],
                    createDefaultProgram: true,
                },
                extends: [
                    'plugin:@angular-eslint/recommended',
                    'plugin:@angular-eslint/template/process-inline-templates',
                ],
                rules: codeRules,
            },
            {
                files: ['*.html'],
                extends: ['plugin:@angular-eslint/template/recommended'],
                rules: {},
            },
        ],
    };
}
exports.createRootESLintConfig = createRootESLintConfig;
function createProjectESLintConfig(rootPath, projectRoot, projectType, prefix) {
    return {
        extends: `${offsetFromRoot(rootPath)}.eslintrc.json`,
        ignorePatterns: ['!**/*'],
        overrides: [
            {
                files: ['*.ts'],
                parserOptions: {
                    project: setESLintProjectBasedOnProjectType(projectRoot, projectType),
                    createDefaultProgram: true,
                },
                rules: {
                    '@angular-eslint/directive-selector': [
                        'error',
                        { type: 'attribute', prefix, style: 'camelCase' },
                    ],
                    '@angular-eslint/component-selector': [
                        'error',
                        { type: 'element', prefix, style: 'kebab-case' },
                    ],
                },
            },
            {
                files: ['*.html'],
                rules: {},
            },
        ],
    };
}
function createESLintConfigForProject(projectName) {
    return (tree) => {
        const angularJSON = readJsonInTree(tree, 'angular.json');
        const { root: projectRoot, projectType, prefix } = angularJSON.projects[projectName];
        /**
         * If the root is an empty string it must be the initial project created at the
         * root by the Angular CLI's workspace schematic. We handle creating the root level
         * config in our own workspace schematic.
         */
        if (projectRoot === '') {
            return;
        }
        return updateJsonInTree(core_1.join(core_1.normalize(projectRoot), '.eslintrc.json'), () => createProjectESLintConfig(tree.root.path, projectRoot, projectType, prefix));
    };
}
exports.createESLintConfigForProject = createESLintConfigForProject;
function removeTSLintJSONForProject(projectName) {
    return (tree) => {
        const angularJSON = readJsonInTree(tree, 'angular.json');
        const { root: projectRoot } = angularJSON.projects[projectName];
        tree.delete(core_1.join(core_1.normalize(projectRoot || '/'), 'tslint.json'));
    };
}
exports.removeTSLintJSONForProject = removeTSLintJSONForProject;
function createRootESLintConfigFile(workspaceName) {
    return (tree) => {
        var _a;
        const angularJSON = readJsonInTree(tree, core_1.join(core_1.normalize(workspaceName), 'angular.json'));
        let lintPrefix = null;
        if ((_a = angularJSON.projects) === null || _a === void 0 ? void 0 : _a[workspaceName]) {
            const { prefix } = angularJSON.projects[workspaceName];
            lintPrefix = prefix;
        }
        return updateJsonInTree(core_1.join(core_1.normalize(workspaceName), '.eslintrc.json'), () => createRootESLintConfig(lintPrefix));
    };
}
exports.createRootESLintConfigFile = createRootESLintConfigFile;
function sortObjectByKeys(obj) {
    return Object.keys(obj)
        .sort()
        .reduce((result, key) => {
        return Object.assign(Object.assign({}, result), { [key]: obj[key] });
    }, {});
}
exports.sortObjectByKeys = sortObjectByKeys;
